Binary files src/_buggy and src-finished/_buggy differ
diff -ruN src/buggy.c src-finished/buggy.c
--- src/buggy.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/buggy.c	2023-04-19 21:56:26.234200068 +0000
@@ -0,0 +1,48 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+
+/*Stress test : Testing modification to anonymous memory mapped by mmap in a loop.*/
+void test() {
+  int size =  10;  /* we need 10 bytes */
+ 
+  char *addr = (char*)0x4000;
+  char* str = mmap(addr, size,  0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
+
+  if (str<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
+    return;
+  }
+
+  strcpy(str, "012345");
+
+  printf(1, "XV6_TEST_OUTPUT : str = %s\n", (char*)str);
+
+  int rv = munmap(str, size);
+  if (rv < 0) {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    return;
+  }
+
+  return;
+}
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+
+  for(i=1;i<=100;i++)
+  {
+    test();
+  }
+  
+  exit();
+}
diff -ruN src/defs.h src-finished/defs.h
--- src/defs.h	2023-04-19 21:56:26.246201230 +0000
+++ src-finished/defs.h	2023-04-19 21:56:26.234200068 +0000
@@ -69,6 +69,14 @@
 void            kinit1(void*, void*);
 void            kinit2(void*, void*);
 
+// kmalloc.c
+void*           kmalloc(uint);
+void            kmfree(void*);
+
+//mmap.c
+void*           mmap(void *, int, int, int, int, int);
+int             munmap(void *, int);
+
 // kbd.c
 void            kbdintr(void);
 
Binary files src/_five and src-finished/_five differ
diff -ruN src/five.c src-finished/five.c
--- src/five.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/five.c	2023-04-19 21:56:26.238200455 +0000
@@ -0,0 +1,60 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "mmu.h"
+
+
+/*Testing whether address returned by anonymous mmap is page aligned.*/
+int
+main(int argc, char *argv[])
+{
+  int size = 200;
+  char *r1 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
+
+  char *r2 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
+
+  char *r3 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
+
+  int rem1 = ((int)r1 % PGSIZE);
+  int rem2 = ((int)r2 % PGSIZE);
+  int rem3 = ((int)r3 % PGSIZE);
+
+  printf(1, "XV6_TEST_OUTPUT : rem1 = %d rem2 = %d rem3 = %d\n",rem1,rem2,rem3);
+
+  if(rem1 != 0 || rem2 != 0 || rem3 != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : Address returned by mmap should be page aligned\n");
+    exit();
+  }
+
+  printf(1, "XV6_TEST_OUTPUT : mmap good --> address returned is page aligned\n");
+
+  int rv1 = munmap(r1, size);
+  if (rv1 < 0) {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+
+  int rv2 = munmap(r2, size);
+  if (rv2 < 0) {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+
+
+  int rv3 = munmap(r3, size);
+  if (rv3 < 0) {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+  
+  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
+
+  exit();
+}
diff -ruN src/kmalloc.c src-finished/kmalloc.c
--- src/kmalloc.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/kmalloc.c	2023-04-19 21:56:26.238200455 +0000
@@ -0,0 +1,92 @@
+#include "types.h"
+#include "stat.h"
+#include "defs.h"
+#include "param.h"
+
+typedef long Align;
+
+union header {
+  struct {
+    union header *ptr;
+    uint size;
+  } s;
+  Align x;
+};
+
+typedef union header Header;
+
+static Header base;
+static Header *freep;
+
+void
+kmfree(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+      
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+  freep = p;
+}
+
+static Header*
+morecore(uint nu)
+{
+    //check less than 4096
+  char *p;
+  Header *hp;
+
+  p = kalloc();
+  if(p == 0)
+    return 0;
+  hp = (Header*)p;
+  hp->s.size = 4096 / sizeof(Header);
+  kmfree((void*)(hp + 1));
+  return freep;
+}
+
+void*
+kmalloc(uint nbytes)
+{
+  Header *p, *prevp;
+  uint nunits;
+
+  if(nbytes > 4096)
+  {
+    panic("kmalloc: requested more than allowed in a single allocation");
+  }
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+      if(p->s.size == nunits)
+        prevp->s.ptr = p->s.ptr;
+      else {
+        p->s.size -= nunits;
+        p += p->s.size;
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+}
diff -ruN src/Makefile src-finished/Makefile
--- src/Makefile	2023-04-19 21:56:26.246201230 +0000
+++ src-finished/Makefile	2023-04-19 21:56:26.234200068 +0000
@@ -7,6 +7,8 @@
 	ide.o\
 	ioapic.o\
 	kalloc.o\
+	kmalloc.o\
+	mmap.o\
 	kbd.o\
 	lapic.o\
 	log.o\
@@ -28,6 +30,7 @@
 	vectors.o\
 	vm.o\
 
+
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
 
@@ -181,6 +184,10 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_xv6_2\
+	_buggy\
+	_five\
+
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -248,12 +255,15 @@
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	mkfs.c xv6_2.c buggy.c five.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
+	kmalloc.c\
+	mmap.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
+
 dist:
 	rm -rf dist
 	mkdir dist
diff -ruN src/Makefile.test src-finished/Makefile.test
--- src/Makefile.test	2023-04-19 21:56:26.246201230 +0000
+++ src-finished/Makefile.test	2023-04-19 21:56:26.234200068 +0000
@@ -8,6 +8,7 @@
 	ioapic.o\
 	kalloc.o\
 	kbd.o\
+	kmalloc.o\
 	lapic.o\
 	log.o\
 	main.o\
@@ -27,6 +28,7 @@
 	uart.o\
 	vectors.o\
 	vm.o\
+	mmap.o\
 
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
@@ -181,6 +183,7 @@
 	_test_5\
 	_test_6\
 	_test_7\
+	_test_8\
 	_mkdir\
 	_rm\
 	_sh\
@@ -258,6 +261,8 @@
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
+	kmalloc.c\
+	mmap.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff -ruN src/mmap.c src-finished/mmap.c
--- src/mmap.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/mmap.c	2023-04-19 21:56:26.238200455 +0000
@@ -0,0 +1,115 @@
+#include "types.h"
+#include "x86.h"
+#include "defs.h"
+#include "date.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+
+#define MMAPBASE (KERNBASE / 2)
+void *mmap(void *addr, int length, int prot, int flags, int fd, int offset)
+{
+
+    if (addr < (void *)0 || addr == (void *)KERNBASE || addr > (void *)KERNBASE || length < 1)
+    {
+        return (void *)-1;
+    }
+    
+    struct proc *p = myproc();
+
+    // uint total_length = 0;
+
+    // new item in linked list
+    mmapped_region *r = (mmapped_region *)kmalloc(sizeof(mmapped_region));
+
+    // fill up
+    r->start_addr = (void *)PGROUNDUP(MMAPBASE);
+    r->length = length;
+    r->region_type = flags;
+    r->offset = offset;
+    r->prot = prot;
+    r->next = 0;
+
+    int total_length = length;
+    if (p->nregions == 0)
+    {
+        p->first_region = r;
+    }
+    else
+    {
+        // can probably just use this instead of the if statement but be safe for now
+        int i;
+        mmapped_region *active = p->first_region;
+
+        for (i = 0; i < p->nregions; i++)
+        {
+            active = active->next;
+            total_length += PGROUNDUP(active->length);
+            r->start_addr += PGROUNDUP(active->length);
+        }
+        active->next = r;
+    }
+    uint start = (uint)r->start_addr;
+    
+    allocuvm(p->pgdir, start, start+total_length);
+    p->nregions++;
+
+    return r->start_addr; // fix this when I start freeing regions
+}
+
+int munmap(void *addr, int length)
+{
+    struct proc *p = myproc();
+    if (p->nregions == 0)
+    {
+        return -1;
+    }
+
+    mmapped_region *active = p->first_region;
+    mmapped_region *previous = 0;
+    int counter = 0;
+
+    while (counter < p->nregions)
+    {
+
+        // return (int)(active->start_addr);
+        if ((active->start_addr) == addr)
+        {
+
+            // xv6_2
+            // make clean && make qemu-nox
+
+            if ((active->length) == length)
+            {
+
+                // deallocuvm(p->pgdir, PGROUNDUP((int)addr), PGROUNDUP((int)addr - length));
+                deallocuvm(p->pgdir, PGROUNDUP((int)addr + length), PGROUNDUP((int)addr));
+                // first node
+                if (previous == 0)
+                {
+                    p->first_region = active->next;
+                }
+                // not first node
+                else
+                {
+                    previous->next = active->next;
+                }
+                kmfree(active);
+                p->nregions--;
+
+                return 42;
+            }
+        }
+
+        if (active->next == 0)
+        {
+            return -1;
+        }
+        // previous = active;
+        active = active->next;
+        counter++;
+    }
+
+    return -1;
+}
\ No newline at end of file
diff -ruN src/proc.c src-finished/proc.c
--- src/proc.c	2023-04-19 21:56:26.246201230 +0000
+++ src-finished/proc.c	2023-04-19 21:56:26.242200842 +0000
@@ -7,7 +7,8 @@
 #include "proc.h"
 #include "spinlock.h"
 
-struct {
+struct
+{
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
@@ -20,32 +21,32 @@
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
+void pinit(void)
 {
   initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
+int cpuid()
+{
+  return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int apicid, i;
-  
-  if(readeflags()&FL_IF)
+
+  if (readeflags() & FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
+  for (i = 0; i < ncpu; ++i)
+  {
     if (cpus[i].apicid == apicid)
       return &cpus[i];
   }
@@ -54,8 +55,9 @@
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
+struct proc *
+myproc(void)
+{
   struct cpu *c;
   struct proc *p;
   pushcli();
@@ -65,12 +67,12 @@
   return p;
 }
 
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
-static struct proc*
+// PAGEBREAK: 32
+//  Look in the process table for an UNUSED proc.
+//  If found, change state to EMBRYO and initialize
+//  state required to run in the kernel.
+//  Otherwise return 0.
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
@@ -78,8 +80,8 @@
 
   acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == UNUSED)
       goto found;
 
   release(&ptable.lock);
@@ -92,7 +94,8 @@
   release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0)
+  {
     p->state = UNUSED;
     return 0;
   }
@@ -100,33 +103,32 @@
 
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+  p->tf = (struct trapframe *)sp;
 
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
-  *(uint*)sp = (uint)trapret;
+  *(uint *)sp = (uint)trapret;
 
   sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
+  p->context = (struct context *)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
   return p;
 }
 
-//PAGEBREAK: 32
-// Set up first user process.
-void
-userinit(void)
+// PAGEBREAK: 32
+//  Set up first user process.
+void userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if ((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
@@ -137,7 +139,7 @@
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
+  p->tf->eip = 0; // beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -155,18 +157,20 @@
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  if (n > 0)
+  {
+    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  }
+  else if (n < 0)
+  {
+    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
   }
   curproc->sz = sz;
@@ -177,20 +181,21 @@
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
+  {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -200,11 +205,24 @@
   np->parent = curproc;
   *np->tf = *curproc->tf;
 
+  np->nregions = curproc->nregions;
+  np->first_region = curproc->first_region;
+
+  mmapped_region *oldactive = curproc->first_region;
+  mmapped_region *newactive = np->first_region;
+  for (i = 0; i < curproc->nregions; i++)
+  {
+    newactive->next = oldactive->next;
+    newactive = newactive->next;
+    oldactive = oldactive->next;
+     
+  }
+
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
   np->cwd = idup(curproc->cwd);
 
@@ -224,19 +242,20 @@
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if (curproc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++)
+  {
+    if (curproc->ofile[fd])
+    {
       fileclose(curproc->ofile[fd]);
       curproc->ofile[fd] = 0;
     }
@@ -253,10 +272,12 @@
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->parent == curproc)
+    {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE)
         wakeup1(initproc);
     }
   }
@@ -269,22 +290,24 @@
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
+int wait(void)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
-  for(;;){
+  for (;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE)
+      {
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -301,39 +324,41 @@
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+    if (!havekids || curproc->killed)
+    {
       release(&ptable.lock);
       return -1;
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sleep(curproc, &ptable.lock); // DOC: wait-sleep
   }
 }
 
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
-void
-scheduler(void)
+// PAGEBREAK: 42
+//  Per-CPU process scheduler.
+//  Each CPU calls scheduler() after setting itself up.
+//  Scheduler never returns.  It loops, doing:
+//   - choose a process to run
+//   - swtch to start running that process
+//   - eventually that process transfers control
+//       via swtch back to the scheduler.
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
-  for(;;){
+
+  for (;;)
+  {
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->state != RUNNABLE)
         continue;
 
       // Switch to chosen process.  It is the process's job
@@ -351,7 +376,6 @@
       c->proc = 0;
     }
     release(&ptable.lock);
-
   }
 }
 
@@ -362,19 +386,18 @@
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&ptable.lock))
+  if (!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  if (mycpu()->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
@@ -382,10 +405,9 @@
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
+  acquire(&ptable.lock); // DOC: yieldlock
   myproc()->state = RUNNABLE;
   sched();
   release(&ptable.lock);
@@ -393,14 +415,14 @@
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
   release(&ptable.lock);
 
-  if (first) {
+  if (first)
+  {
     // Some initialization functions must be run in the context
     // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
@@ -414,15 +436,14 @@
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
-  if(p == 0)
+
+  if (p == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -431,8 +452,9 @@
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  if (lk != &ptable.lock)
+  {                        // DOC: sleeplock0
+    acquire(&ptable.lock); // DOC: sleeplock1
     release(lk);
   }
   // Go to sleep.
@@ -445,28 +467,28 @@
   p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if (lk != &ptable.lock)
+  { // DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
 }
 
-//PAGEBREAK!
-// Wake up all processes sleeping on chan.
-// The ptable lock must be held.
+// PAGEBREAK!
+//  Wake up all processes sleeping on chan.
+//  The ptable lock must be held.
 static void
 wakeup1(void *chan)
 {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == SLEEPING && p->chan == chan)
       p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
   acquire(&ptable.lock);
   wakeup1(chan);
@@ -476,17 +498,18 @@
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
   struct proc *p;
 
   acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if (p->state == SLEEPING)
         p->state = RUNNABLE;
       release(&ptable.lock);
       return 0;
@@ -496,37 +519,37 @@
   return -1;
 }
 
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+// PAGEBREAK: 36
+//  Print a process listing to console.  For debugging.
+//  Runs when user types ^P on console.
+//  No lock to avoid wedging a stuck machine further.
+void procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
+      [UNUSED] "unused",
+      [EMBRYO] "embryo",
+      [SLEEPING] "sleep ",
+      [RUNNABLE] "runble",
+      [RUNNING] "run   ",
+      [ZOMBIE] "zombie"};
   int i;
   struct proc *p;
   char *state;
   uint pc[10];
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
+    if (p->state == SLEEPING)
+    {
+      getcallerpcs((uint *)p->context->ebp + 2, pc);
+      for (i = 0; i < 10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
diff -ruN src/proc.h src-finished/proc.h
--- src/proc.h	2023-04-19 21:56:26.246201230 +0000
+++ src-finished/proc.h	2023-04-19 21:56:26.242200842 +0000
@@ -1,30 +1,32 @@
 // Per-CPU state
-struct cpu {
-  uchar apicid;                // Local APIC ID
-  struct context *scheduler;   // swtch() here to enter scheduler
-  struct taskstate ts;         // Used by x86 to find stack for interrupt
-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
-  volatile uint started;       // Has the CPU started?
-  int ncli;                    // Depth of pushcli nesting.
-  int intena;                  // Were interrupts enabled before pushcli?
-  struct proc *proc;           // The process running on this cpu or null
+struct cpu
+{
+  uchar apicid;              // Local APIC ID
+  struct context *scheduler; // swtch() here to enter scheduler
+  struct taskstate ts;       // Used by x86 to find stack for interrupt
+  struct segdesc gdt[NSEGS]; // x86 global descriptor table
+  volatile uint started;     // Has the CPU started?
+  int ncli;                  // Depth of pushcli nesting.
+  int intena;                // Were interrupts enabled before pushcli?
+  struct proc *proc;         // The process running on this cpu or null
 };
 
 extern struct cpu cpus[NCPU];
 extern int ncpu;
 
-//PAGEBREAK: 17
-// Saved registers for kernel context switches.
-// Don't need to save all the segment registers (%cs, etc),
-// because they are constant across kernel contexts.
-// Don't need to save %eax, %ecx, %edx, because the
-// x86 convention is that the caller has saved them.
-// Contexts are stored at the bottom of the stack they
-// describe; the stack pointer is the address of the context.
-// The layout of the context matches the layout of the stack in swtch.S
-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
-// but it is on the stack and allocproc() manipulates it.
-struct context {
+// PAGEBREAK: 17
+//  Saved registers for kernel context switches.
+//  Don't need to save all the segment registers (%cs, etc),
+//  because they are constant across kernel contexts.
+//  Don't need to save %eax, %ecx, %edx, because the
+//  x86 convention is that the caller has saved them.
+//  Contexts are stored at the bottom of the stack they
+//  describe; the stack pointer is the address of the context.
+//  The layout of the context matches the layout of the stack in swtch.S
+//  at the "Switch stacks" comment. Switch doesn't save eip explicitly,
+//  but it is on the stack and allocproc() manipulates it.
+struct context
+{
   uint edi;
   uint esi;
   uint ebx;
@@ -32,12 +34,34 @@
   uint eip;
 };
 
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate
+{
+  UNUSED,
+  EMBRYO,
+  SLEEPING,
+  RUNNABLE,
+  RUNNING,
+  ZOMBIE
+};
+
+typedef struct mmapped_region
+{
+  // Linked-List pointers
+  struct mmapped_region *next;
 
+  // Region Meta-Data:
+  void *start_addr; // starting address for mapped region
+  int length;      // length of allocated region
+  int region_type;  // anonymous of file-backed
+  int offset;       // offset in a file-backed allocation
+  int fd;           // file descriptor (-1 for anonymous allocation)
+  int prot;         // protection bits for the mapped region (default is read-only)
+} mmapped_region;
 // Per-process state
-struct proc {
+struct proc
+{
   uint sz;                     // Size of process memory (bytes)
-  pde_t* pgdir;                // Page table
+  pde_t *pgdir;                // Page table
   char *kstack;                // Bottom of kernel stack for this process
   enum procstate state;        // Process state
   int pid;                     // Process ID
@@ -49,6 +73,8 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int nregions;                
+  mmapped_region *first_region; 
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff -ruN src/syscall.c src-finished/syscall.c
--- src/syscall.c	2023-04-19 21:56:26.246201230 +0000
+++ src-finished/syscall.c	2023-04-19 21:56:26.242200842 +0000
@@ -103,6 +103,10 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_kmalloc(void);
+extern int sys_kmfree(void);
+extern int sys_mmap(void);    
+extern int sys_munmap(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +130,11 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_kmalloc] sys_kmalloc,
+[SYS_kmfree]  sys_kmfree,
+[SYS_mmap]    sys_mmap,
+[SYS_munmap]  sys_munmap,
+
 };
 
 void
diff -ruN src/syscall.h src-finished/syscall.h
--- src/syscall.h	2023-04-19 21:56:26.246201230 +0000
+++ src-finished/syscall.h	2023-04-19 21:56:26.242200842 +0000
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_kmalloc 22
+#define SYS_kmfree  23 
+#define SYS_mmap    24  
+#define SYS_munmap  25  
\ No newline at end of file
diff -ruN src/sysproc.c src-finished/sysproc.c
--- src/sysproc.c	2023-04-19 21:56:26.246201230 +0000
+++ src-finished/sysproc.c	2023-04-19 21:56:26.242200842 +0000
@@ -89,3 +89,84 @@
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_kmalloc(void)
+{
+  int nbytes;
+
+  if(argint(0, &nbytes) < 0)
+    return -1;
+
+  return (int)kmalloc((uint)nbytes);
+}
+
+int
+sys_kmfree(void)
+{
+  int addr;
+
+  if(argint(0, &addr) < 0)
+    return -1;
+
+  kmfree((void*)addr);
+
+  return 0;
+}
+
+int
+sys_mmap(void)
+{
+  int addr;
+  int length;
+  int prot;
+  int flags;
+  int fd;
+  int offset;
+
+  if(argint(0, &addr) < 0)
+  {
+    return -1;
+  }
+  if(argint(1, &length) < 0)
+  {
+    return -1;
+  }
+  if(argint(2, &prot) < 0)
+  {
+    return -1;
+  }
+  if(argint(3, &flags) < 0)
+  {
+    return -1;
+  }
+  if(argint(4, &fd) < 0)
+  {
+    return -1;
+  }
+  if(argint(5, &offset) < 0)
+  {
+    return -1;
+  }
+
+  return (int)mmap((void*)addr, (uint)length, (uint)prot,
+                    (uint)flags, (uint)fd, (uint)offset);
+}
+
+int
+sys_munmap(void)
+{
+  int addr;
+  int length;
+
+  if(argint(0, &addr) < 0)
+  {
+    return -1;
+  }
+  if(argint(1, &length) < 0)
+  {
+    return -1;
+  }
+
+  return munmap((void*)addr, (uint)length);
+}
\ No newline at end of file
diff -ruN src/test_1.c src-finished/test_1.c
--- src/test_1.c	2023-04-19 02:18:53.355860186 +0000
+++ src-finished/test_1.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,32 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-  for(i=1;i<=500;i++)
-  {
-    void* addr = kmalloc(2000);
-
-    if(addr == 0)
-    {
-      printf(1, "XV6_TEST_OUTPUT : kmalloc failed to allocate memory\n");
-      exit();
-    }
-
-    kmfree(addr);
-  }
-
-  printf(1, "XV6_TEST_OUTPUT : kmalloc  and kmfree good.\n");
-
-  exit();
-}
diff -ruN src/test_2.c src-finished/test_2.c
--- src/test_2.c	2023-04-19 02:18:53.359860661 +0000
+++ src-finished/test_2.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,76 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-
-/*Test simple mmap and munmap.
-Test mmap has zeroed the newly mapped anonymous region.*/
-int memcmp(const void *v1, const void *v2, uint n)
-{
-  const uchar *s1, *s2;
-
-  s1 = v1;
-  s2 = v2;
-  while (n-- > 0)
-  {
-    if (*s1 != *s2)
-      return *s1 - *s2;
-
-    s1++, s2++;
-  }
-
-  return 0;
-}
-
-void test()
-{
-  int size = 10;
-  void *zeroes;
-
-  void *res = 0;
-  res = mmap(res, size, 0 /*prot*/, 0 /*flags*/, -1 /*fd*/, 0 /*offset*/);
-  if (res <= 0)
-  {
-    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
-    return;
-  }
-
-  printf(1, "XV6_TEST_OUTPUT : mmap good\n");
-
-  zeroes = malloc(size);
-  memset(zeroes, 0, size);
-
-  int ret = memcmp(res, zeroes, size);
-  printf(1, "XV6_TEST_OUTPUT : Ret of memcmp %d\n", ret);
-
-  if (ret != 0)
-  {
-    printf(1, "XV6_TEST_OUTPUT : mmap() should zero out the  newly mapped anonymous memory region.!!\n");
-    return;
-  }
-
-  printf(1, "XV6_TEST_OUTPUT : mmap() has correctly cleared the newly mapped anonymous memory region\n");
-  printf(1, "given size here size: %d\n", size);
-  int rv = munmap(res, size);
-  printf(1, "given size here size: %d\n", size);
-  printf(1, "size: %d\n", rv);
-  if (rv < 0)
-  {
-    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
-    return;
-  }
-
-  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
-  return;
-}
-
-int main(int argc, char *argv[])
-{
-  test();
-  exit();
-}
diff -ruN src/test_3.c src-finished/test_3.c
--- src/test_3.c	2023-04-19 02:18:53.359860661 +0000
+++ src-finished/test_3.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,66 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-
-/* Test modification to memory mapped by mmap.*/
-int
-memcmp(const void *v1, const void *v2, uint n)
-{
-  const uchar *s1, *s2;
-  
-  s1 = v1;
-  s2 = v2;
-  while(n-- > 0)
-  {
-    if(*s1 != *s2)
-     return *s1 - *s2;
-
-    s1++, s2++;
-  }
-
-  return 0;
-}
-
-void test() {
-  int size =  10;  /* we need 10 bytes */
- 
-  char *addr = (char*)0x4000;
-  char* str = mmap(addr, size,  0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
-
-  if (str<=0)
-  {
-    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
-    return;
-  }
-
-  printf(1, "XV6_TEST_OUTPUT : mmap good\n");
-
-  printf(1, "XV6_TEST_OUTPUT : Strlen Before modification: %d\n", strlen((char*)str));
-
-  strcpy(str, "012345");
-
-  printf(1, "XV6_TEST_OUTPUT : str = %s\n", (char*)str);
-  printf(1, "XV6_TEST_OUTPUT : Strlen After modification: %d\n", strlen((char*)str));
-
-  int rv = munmap(str, size);
-  if (rv < 0) {
-    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
-    return;
-  }
-
-  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
-  return;
-}
-
-int
-main(int argc, char *argv[])
-{
-  test();
-  exit();
-}
diff -ruN src/test_4.c src-finished/test_4.c
--- src/test_4.c	2023-04-19 02:18:53.363861137 +0000
+++ src-finished/test_4.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,48 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-
-/*Stress test : Testing modification to anonymous memory mapped by mmap in a loop.*/
-void test() {
-  int size =  10;  /* we need 10 bytes */
- 
-  char *addr = (char*)0x4000;
-  char* str = mmap(addr, size,  0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
-
-  if (str<=0)
-  {
-    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
-    return;
-  }
-
-  strcpy(str, "012345");
-
-  printf(1, "XV6_TEST_OUTPUT : str = %s\n", (char*)str);
-
-  int rv = munmap(str, size);
-  if (rv < 0) {
-    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
-    return;
-  }
-
-  return;
-}
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  for(i=1;i<=2;i++)
-  {
-    test();
-  }
-  
-  exit();
-}
diff -ruN src/test_5.c src-finished/test_5.c
--- src/test_5.c	2023-04-19 02:18:53.367861613 +0000
+++ src-finished/test_5.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,60 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-#include "mmu.h"
-
-
-/*Testing whether address returned by anonymous mmap is page aligned.*/
-int
-main(int argc, char *argv[])
-{
-  int size = 200;
-  char *r1 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
-
-  char *r2 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
-
-  char *r3 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
-
-  int rem1 = ((int)r1 % PGSIZE);
-  int rem2 = ((int)r2 % PGSIZE);
-  int rem3 = ((int)r3 % PGSIZE);
-
-  printf(1, "XV6_TEST_OUTPUT : rem1 = %d rem2 = %d rem3 = %d\n",rem1,rem2,rem3);
-
-  if(rem1 != 0 || rem2 != 0 || rem3 != 0)
-  {
-    printf(1, "XV6_TEST_OUTPUT : Address returned by mmap should be page aligned\n");
-    exit();
-  }
-
-  printf(1, "XV6_TEST_OUTPUT : mmap good --> address returned is page aligned\n");
-
-  int rv1 = munmap(r1, size);
-  if (rv1 < 0) {
-    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
-    exit();
-  }
-
-  int rv2 = munmap(r2, size);
-  if (rv2 < 0) {
-    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
-    exit();
-  }
-
-
-  int rv3 = munmap(r3, size);
-  if (rv3 < 0) {
-    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
-    exit();
-  }
-  
-  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
-
-  exit();
-}
diff -ruN src/test_6.c src-finished/test_6.c
--- src/test_6.c	2023-04-19 02:18:53.367861613 +0000
+++ src-finished/test_6.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,45 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-#include "mmu.h"
-
-
-/*Stress Testing allocating large sized memory using anonymous mmap in a loop..*/
-int
-main(int argc, char *argv[])
-{
-  int i;
-  for(i = 0;i<100;i++)
-  {
-    int size =  2100;
-    int modifySize = 2000;
- 
-    char *addr = (char*)0x4000;
-    char* r = mmap(addr, size,  0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
-
-    if (r<=0)
-    {
-      printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
-      exit();
-    }
-    
-    memset(r, 'a', modifySize);
-    printf(1, "XV6_TEST_OUTPUT : strlen(r) = %d\n", strlen(r));
-
-    int rv = munmap(r, size);
-    if (rv < 0) 
-    {
-      printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
-      exit();
-    }
-
-  }
-
-  exit();
-}
diff -ruN src/test_7.c src-finished/test_7.c
--- src/test_7.c	2023-04-19 02:18:53.371862089 +0000
+++ src-finished/test_7.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,44 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-#include "mmu.h"
-
-
-/*Stress Testing allocating large sized memory using anonymous mmap spanning across multiple pages..*/
-int
-main(int argc, char *argv[])
-{
-  
-  int size =  2*PGSIZE;
-
-  char *addr = (char*)0x4000;
-  char* r = mmap(addr, size,  0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
-
-  if (r<=0)
-  {
-    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
-    exit();
-  }
-  
-  printf(1, "XV6_TEST_OUTPUT : mmap good\n");
-
-  memset(r, 'a', size - 1);
-  printf(1, "XV6_TEST_OUTPUT : strlen(r) = %d\n", strlen(r));
-
-  int rv = munmap(r, size);
-  if (rv < 0) 
-  {
-    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
-    exit();
-  }
-
-  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
-  
-  exit();
-}
diff -ruN src/traps.h src-finished/traps.h
--- src/traps.h	2023-04-19 21:56:26.250201617 +0000
+++ src-finished/traps.h	2023-04-19 21:56:26.246201230 +0000
@@ -36,3 +36,6 @@
 #define IRQ_ERROR       19
 #define IRQ_SPURIOUS    31
 
+#define T_ERR_PGFLT_P   0x1    
+#define T_ERR_PGFLT_W   0X2    
+#define T_ERR_PGFLT_U   0x4
diff -ruN src/user.h src-finished/user.h
--- src/user.h	2023-04-19 21:56:26.250201617 +0000
+++ src-finished/user.h	2023-04-19 21:56:26.246201230 +0000
@@ -24,6 +24,11 @@
 int sleep(int);
 int uptime(void);
 
+void* kmalloc(int size);
+void kmfree(void* addr);
+void* mmap(void *addr, int length, uint prot, uint flags, uint fd, uint offset);
+int munmap(void *addr, int length);
+
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
diff -ruN src/usys.S src-finished/usys.S
--- src/usys.S	2023-04-19 21:56:26.250201617 +0000
+++ src-finished/usys.S	2023-04-19 21:56:26.246201230 +0000
@@ -29,3 +29,7 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(kmalloc)
+SYSCALL(kmfree) 
+SYSCALL(mmap)
+SYSCALL(munmap) 
\ No newline at end of file
Binary files src/_xv6_2 and src-finished/_xv6_2 differ
diff -ruN src/xv6_2.c src-finished/xv6_2.c
--- src/xv6_2.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/xv6_2.c	2023-04-19 21:56:26.246201230 +0000
@@ -0,0 +1,77 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+
+/*Test simple mmap and munmap.
+Test mmap has zeroed the newly mapped anonymous region.*/
+int memcmp(const void *v1, const void *v2, uint n)
+{
+  const uchar *s1, *s2;
+
+  s1 = v1;
+  s2 = v2;
+  while (n-- > 0)
+  {
+    if (*s1 != *s2)
+      return *s1 - *s2;
+
+    s1++, s2++;
+  }
+
+  return 0;
+}
+
+void test()
+{
+  int size = 10;
+  void *zeroes;
+
+  void *res = 0;
+  res = mmap(res, size, 0 /*prot*/, 0 /*flags*/, -1 /*fd*/, 0 /*offset*/);
+  if (res <= 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
+    return;
+  }
+
+  printf(1, "XV6_TEST_OUTPUT : mmap good\n");
+
+  zeroes = malloc(size);
+  memset(zeroes, 0, size);
+
+  int ret = memcmp(res, zeroes, size);
+  printf(1, "XV6_TEST_OUTPUT : Ret of memcmp %d\n", ret);
+
+  if (ret != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap() should zero out the  newly mapped anonymous memory region.!!\n");
+    return;
+  }
+
+  printf(1, "XV6_TEST_OUTPUT : mmap() has correctly cleared the newly mapped anonymous memory region\n");
+  printf(1, "given size here size: %d\n", size);
+  printf(1, "given addr here: %d\n", res);
+  int rv = munmap(res, size);
+
+  printf(1, "rv here: %d\n", rv);
+  if (rv < 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    return;
+  }
+
+  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
+  return;
+}
+
+int main(int argc, char *argv[])
+{
+  test();
+  exit();
+}
